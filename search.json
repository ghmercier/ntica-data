[
  {
    "objectID": "chapters/outils-quotidiens.html",
    "href": "chapters/outils-quotidiens.html",
    "title": "Les outils du quotidien",
    "section": "",
    "text": "En informatique, de nombreux logiciels libres et gratuits existent. Il répondent efficacement aux besoins de la vie courante et sont souvent bien meilleurs que les outils intégrés à Windows ou Mac OS.\nVoici quelques propositions. On pourra également se référer au catalogue publié par l’État des logiciels libres recommandés pour l’administration.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#compressiondécompression",
    "href": "chapters/outils-quotidiens.html#compressiondécompression",
    "title": "Les outils du quotidien",
    "section": "Compression/décompression",
    "text": "Compression/décompression\nRéduire le volume des données avant de les stocker ou de les transférer. Quelques formats usuels : zip, rar, 7z, tar.gz…\n\n7z, capable de traiter une grande variété de formats.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#visualisation-dimages",
    "href": "chapters/outils-quotidiens.html#visualisation-dimages",
    "title": "Les outils du quotidien",
    "section": "Visualisation d’images",
    "text": "Visualisation d’images\nNaviguer rapidement dans une série d’images.\n\nNomacs, existe en version portable.\nIrfanview, un visualisateur très léger.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#capture-décran",
    "href": "chapters/outils-quotidiens.html#capture-décran",
    "title": "Les outils du quotidien",
    "section": "Capture d’écran",
    "text": "Capture d’écran\nSauvegarder tout ou partie de son écran, en annotant rapidement ce que l’on voit.\n\nGreenshot, pour Windows.\nFlameshot, multi-plateformes.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#retouche-dimages",
    "href": "chapters/outils-quotidiens.html#retouche-dimages",
    "title": "Les outils du quotidien",
    "section": "Retouche d’images",
    "text": "Retouche d’images\nModifier des images raster : recadrer, redimensionner, ajuster les couleurs, etc.\n\nGimp, aussi efficace que Photoshop pour les besoins courants.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#dessin",
    "href": "chapters/outils-quotidiens.html#dessin",
    "title": "Les outils du quotidien",
    "section": "Dessin",
    "text": "Dessin\nDessiner en vectoriel (ex. repérer une parcelle sur une photo, ajouter des textes, etc.) plus proprement qu’en utilisant Paint ou Powerpoint.\n\nInkscape",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#éditeur-de-texte",
    "href": "chapters/outils-quotidiens.html#éditeur-de-texte",
    "title": "Les outils du quotidien",
    "section": "Éditeur de texte",
    "text": "Éditeur de texte\nÉditer du texte brut (ie. sans mise en forme), avec des fonctionnalités avancées : coloration syntaxique, expressions régulières, etc.\n\nNotepad++, très complet.\nNotepad2, simple et efficace au quotidien.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#visionneuse-de-pdf",
    "href": "chapters/outils-quotidiens.html#visionneuse-de-pdf",
    "title": "Les outils du quotidien",
    "section": "Visionneuse de PDF",
    "text": "Visionneuse de PDF\nOuvrir rapidement des fichiers PDF.\n\nSumatra PDF, beaucoup plus léger qu’Acrobat Reader.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#édition-de-pdf",
    "href": "chapters/outils-quotidiens.html#édition-de-pdf",
    "title": "Les outils du quotidien",
    "section": "Édition de PDF",
    "text": "Édition de PDF\nDécouper ou fusionner des fichiers PDF.\n\nPDF Sam Basic",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#cartographie",
    "href": "chapters/outils-quotidiens.html#cartographie",
    "title": "Les outils du quotidien",
    "section": "Cartographie",
    "text": "Cartographie\nFaire des cartes simples ou complexes.\n\nQGIS, client de référence, application de bureau.\nuMap, service en ligne pour des cartes simples et rapides.\nMagrit, un outil de cartographie thématique simple et intuitif développé par le CNRS.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Travaux dirigés NTICA",
    "section": "",
    "text": "Bienvenue à vous, chers élèves AMUR de la promo 2025/2026.\nVous trouverez ci-dessous les liens vers les supports de TD pour apprendre à manipuler des données publiques.",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "index.html#le-ssp-cloud",
    "href": "index.html#le-ssp-cloud",
    "title": "Travaux dirigés NTICA",
    "section": "Le SSP Cloud",
    "text": "Le SSP Cloud\nCes supports sont interactifs. En cliquant sur le bouton prévu à cet effet en haut de la page, vous pourrez les lancer dans le Datalab de la plateforme SSPCloud de l’INSEE.\nCela présente plusieurs avantages :\n\nVous n’avez ainsi rien à installer\nVous disposerez de tous les modules requis aux bonnes versions\nVous aurez accès directement aux données nécessaires\n\nIl vous faudra préalablement créer un compte gratuitement, en indiquant votre adresse email @eleves.enpc.fr.",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "index.html#les-supports-de-td",
    "href": "index.html#les-supports-de-td",
    "title": "Travaux dirigés NTICA",
    "section": "Les supports de TD",
    "text": "Les supports de TD\n\nIntroduction à QGIS\nTraitement de fichiers CSV",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "chapters/chapter1.html",
    "href": "chapters/chapter1.html",
    "title": "Premiers pas en CSV",
    "section": "",
    "text": "Dans ce TD, nous allons apprendre à manipuler un type de fichier texte très utilisé pour stocker et diffuser des données : le CSV.\nCSV est l’abréviation de comma-separated values, soit “valeurs séparées par des virgules” – même si, bien souvent, le délimiteur standard (la virgule) est remplacée par un autre délimiteur.\nUn fichier CSV reproduit la structure d’un tableau :\nUn module de la bibliothèque standard de Python est spécialement conçu pour faciliter l’interaction avec ce type de fichiers : le module csv.\nEn pratique, on utilise souvent des modules de plus haut niveau (comme pandas) pour travailler avec des tableaux (DataFrames).\nNous allons néanmoins nous entraîner à l’utiliser en explorant deux fichiers de l’INSEE :",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#préambule",
    "href": "chapters/chapter1.html#préambule",
    "title": "Premiers pas en CSV",
    "section": "Préambule",
    "text": "Préambule\nCe notebook est conçu pour être interactif. Dans les cellules prévues à cet effet, vous pouvez écrire du code en Python et l’exécuter en pressant SHIFT+ENTER.\nLes variables restent en mémoire d’une cellule à l’autre. Essayez ci-dessous !\n\n# C'est à vous !",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#première-exploration-des-données",
    "href": "chapters/chapter1.html#première-exploration-des-données",
    "title": "Premiers pas en CSV",
    "section": "Première exploration des données",
    "text": "Première exploration des données\nAvant tout, téléchargez les fichiers source sur votre ordinateur et ouvrez-les avec un éditeur de texte brut (comme Notepad++) pour en examiner la structure.\n\nExploration de insee_data.csv\nOn note que :\n\nLe fichier est encodé en UTF-8.\nles valeurs sont séparées par des points-virgules (;).\nLa 1ère ligne du fichier contient le nom des colonnes : c’est l’entête, ou header.\nLes 34 785 autres lignes contiennent les données, une ligne par commune.\n\nOn relève qu’il y a quatre colonnes :\n\nCode : le numéro INSEE de la commune.\nLibellé : le nom de la commune.\nPopulation municipale 2022 : la population de référence de la commune, millésime 2022, entrée en vigueur le 1er janvier 2025, donnée issue du recensement de la population.\nBoulangerie-pâtisserie (en nombre) 2024 : le nombre de boulangeries-pâtisseries que comptait la commune en 2024, donnée issue de la Base Permanente des Équipements (BPE).\n\n\n\nExploration de v_departement_2025.csv\nOn note que :\n\nLe fichier est encodé en UTF-8.\nles valeurs sont séparées par des virgules (,).\nLe fichier comporte un header.\nLes 101 autres lignes contiennent les données, une ligne par département.\n\nOn relève qu’il y a sept colonnes :\n\nREGION : code région.\nDEP : code département.\nCHEFLIEU : code de la commune chef-lieu.\nTNCC : Type de nom en clair (donne une indication grammaticale).\nNCC : Nom en clair, en majuscules.\nNCCENR : Nom en clair, en minuscules accentuées.\nLIBELLE : Nom en clair, en minuscules accentuées avec article.",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#chargement-des-données",
    "href": "chapters/chapter1.html#chargement-des-données",
    "title": "Premiers pas en CSV",
    "section": "Chargement des données",
    "text": "Chargement des données\n\nPrincipe\nOn peut modéliser les données avec Python de plusieurs manières.\n\nListe de listes\nOn peut construire une liste de listes : la grande liste représente le tableau, elle contient plusieurs listes (autant que de lignes) dont chacun des élements représentent les valeurs des colonnes.\n\n# On importe le module CSV\nimport csv\n\n# On crée la première liste\nrows = []\n\n# On ouvre le fichier en mode lecture ('r') en spécifiant l'encodage ('utf-8'),\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n\n    # On crée un objet reader() qui lit une ligne du fichier qui lui est passé,\n    # détecte les délimiteurs et renvoie la liste des champs qu'ils séparent \n    csv_reader = csv.reader(mf, delimiter=';')\n\n    # Cet objet est conçu comme un itérateur : à chaque fois qu'on l'appelle,\n    # il passe à la ligne suivante, jusqu'à la fin du fichier. \n    # On stocke ainsi toutes les listes renvoyées dans la première liste.\n    for row in csv_reader:\n        rows.append(row)\n\n# On affiche la valeur stockée 13e ligne, 2eme colonne\n# (pour mémoire, Python compte à partir de 0) :\nprint('La valeur à la 13e ligne, 2eme colonne est la suivante : ', end=None)\nprint(rows[12][1])\n\n\n\nListe de dictionnaires\nMais puisque notre fichier comporte un entête, il est intéressant de modéliser les données sous la forme d’une liste de dictionnaires : chaque ligne sera représentée par un dictionnaire qui fait correspondre aux noms des colonnes (ex: Code) leurs valeurs (ex: '01001').\nPour montrer l’intérêt, on ne conservera ici que les communes dont le champ Code commence par '77' (c’est-à-dire les communes de Seine-et-Marne).\n\n# On crée une autre liste\nseinemarne = []\n\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n   \n    # On utilise ici un objet DictReader()\n    csv_reader = csv.DictReader(mf, delimiter=';')\n    \n    # Les objets renvoyés à chaque appel sont donc des dictionnaires\n    for dico in csv_reader:\n        \n        # On utilise la méthode `startswith` dont disposent les objets de type \n        # natif `str` pour filtrer les éléments qui nous intéressent\n        if dico['Code'].startswith('77'):\n            seinemarne.append(dico)\n\n# On affiche le libellé du dernier élément de la liste ainsi constituée\nlibelle = seinemarne[-1]['Libellé']\nprint(\"La dernière ville de la liste est : {}\".format(libelle))\n\n\n\n\nÀ vous de jouer !\n\nChargement de insee_data.csv\nChargez les données du fichier insee_data.csvdans une liste de dictionnaires que vous nommerez communes.\nAffichez le nom et la population de la 10 000e ville de la liste.\n\n# Entrez ici votre code\n\n\n\nSolution\ncommunes = []\n\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n    csv_reader = csv.DictReader(mf, delimiter=';')\n    for row in csv_reader:\n        communes.append(row)\n\n\nprint(\"La 10000e ville de la liste est : {}, {} habitants.\".format(\n    communes[9999]['Libellé'],\n    communes[9999]['Population municipale 2022']\n    )\n)\n\n\n\n\nChargement de v_departement_2025.csv\nChargez les données du fichier v_departement_2025.csv dans une liste de dictionnaires que vous nommerez depts.\nAffichez le nom en majuscule du 17e département de la liste.\n\n# Entrez ici votre code\n\n\n\nSolution\ndepts = []\n\nwith open('data/v_departement_2025.csv', 'r', encoding='utf-8') as mf:\n    csv_reader = csv.DictReader(mf, delimiter=',')\n    for row in csv_reader:\n        depts.append(row)\n\nprint(\"Le 17eme département de la liste est : {}.\".format(depts[16]['NCC']))",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#vérification-et-nettoyage-des-données",
    "href": "chapters/chapter1.html#vérification-et-nettoyage-des-données",
    "title": "Premiers pas en CSV",
    "section": "Vérification et nettoyage des données",
    "text": "Vérification et nettoyage des données\nIl est utile de vérifier que les données ne présentent pas de “bizarreries” (éléments aberrants, valeurs manquantes, etc.).\nNous allons conduire quelques tests de cohérence.\n\nNombre de champs pour chaque enregistrement\nOn va s’assurer que chaque enregistrement des listes communes et depts comporte le bon nombre de champs : 4 pour les communes, 7 pour les départements.\nÉcrivez un programme qui vérifie pour les deux listes que chaque dictionnaire contient le nombre approprié de clés. On stockera dans des listes à part les problèmes éventuels (si tout va bien, ces listes seront vides).\n\n# Entrez ici votre code\n\n\n\nSolution\n# Pour les communes tout d'abord\n# On le fait de façon naïve, avec une boucle traditionnelle\ncommunes_avec_pb = []\nfor com in communes:\n    if len(com) != 4:\n        communes_avec_pb.append(com)\n\nprint(\"{} enregistrements problématiques dans la liste 'communes'\".format(\n    len(communes_avec_pb)\n    )\n)\n\n# Pour les départements ensuite\n# On le fait e façon pythonique, avec une compréhension de liste\ndept_avec_pb = [dep for dep in depts if len(dep) != 7]\n\nprint(\"{} enregistrements problématiques dans la liste 'dept'\".format(\n    len(dept_avec_pb)\n    )\n)\n\n\n\n\nCohérence géographique\nDans la liste depts, on va vérifier que la commune désignée comme chef-lieu d’un département appartient bien à ce département.\nOn se souviendra que le code INSEE d’une commune commence par le numéro du département auquel elle appartient, codé sur 2 caractères (3 pour l’outre-mer).\n\n# Entrez ici votre code\n\n\n\nSolution\n# Voici la façon naïve, avec une boucle traditionnelle\npb_chef_lieu = []\nfor dep in depts:\n    codeinsee = dep['CHEFLIEU']\n    if codeinsee[:2] != dep['DEP'] and codeinsee[:3] != dep['DEP']:\n        pb_chef_lieu.append(dep)\n\npb_chef_lieu\n\n# Et la même chose de façon pythonique, avec une compréhension de liste\npb_chef_lieu = [ \n    dep for depts in depts \n    if  dep['CHEFLIEU'][:2] != dep['DEP']\n    and dep['CHEFLIEU'][:3] != dep['DEP']\n]\n\nprint(\"{} communes situées hors du département.\".format(len(pb_chef_lieu)))\n\n\n\n\nValeurs manquantes\nBien souvent, les données manquantes dans une série de données sont signalées par une chaîne de caractère spécifique (comme N/A) et non par l’absence de valeurs. Cela peut-être gênant.\nDans la table communes, on va ainsi filtrer les enregistrements qui contiennent des valeurs non numériques dans les champs de données.\nOn utilisera pour cela la méthode is_decimal dont disposent les objets de type natif str (cf documentation). Cette méthode renvoie True si tous les caractères d’une chaîne sont des caractères décimaux et qu’elle contient au moins un caractère, False sinon.\n\n# Entrez ici votre code\n\n\n\nSolution\n# Voici la façon naïve, avec une boucle traditionnelle\npb_nombre = []\nfor com in communes:\n    if not com['Population municipale 2022'].isdecimal():\n        pb_nombre.append(com)\n        next\n    elif not com['Boulangerie-pâtisserie (en nombre) 2024'].isdecimal():\n        pb_nombre.append(com)\n\n\n# Et la même chose de façon pythonique, avec une compréhension de liste\npb_nombre = [\n    com for com in communes\n    if not com['Population municipale 2022'].isdecimal()\n    or not com['Boulangerie-pâtisserie (en nombre) 2024'].isdecimal()\n]\n\nprint(\"{} communes avec données manquantes.\".format(len(pb_nombre)))\n\n\nAinsi donc, des données sont manquantes pour une vingtaine de communes… On les éliminera de la liste communes.\n\n# Entrez ici votre code\n\n\n\nSolution\nprint(\"Nombre d'enregistrements avant nettoyage : {}\".format(len(communes)))\n\nfor ville in pb_nombre:\n    communes.remove(ville)\n\nprint(\"Nombre d'enregistrements après nettoyage : {}\".format(len(communes)))\n\n\n\n\nGestion des types\nDans la liste communes, les valeurs stockées dans les champs de données sont pour l’instant représentées par des chaînes de caractères.\n\nprint(type(communes[0]['Population municipale 2022']))\n\nPour les utiliser dans des calculs, il faut d’abord les convertir en nombres entiers. Allez-y !\n\n# Entrez ici votre code\n\n\n\nSolution\nfor c in communes:\n    for champ in ['Population municipale 2022', 'Boulangerie-pâtisserie (en nombre) 2024']:\n        c[champ] = int(c[champ])\n\nprint(type(communes[0]['Population municipale 2022']))",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#requêtes-sur-les-données",
    "href": "chapters/chapter1.html#requêtes-sur-les-données",
    "title": "Premiers pas en CSV",
    "section": "Requêtes sur les données",
    "text": "Requêtes sur les données\nUtilisez les deux tables communes et depts construites précédemment pour répondre aux questions suivantes.\n\nBoulangeries de(s) Champs\nCombien y a-t-il de boulangeries à Champs-sur-Marne (77083) ?\n\n# Entrez ici votre code\n\n\n\nSolution\nfor c in communes:\n    if c['Code'] == '77083':\n        print(\"{} : {} boulangeries\".format(\n            c['Libellé'],\n            c['Boulangerie-pâtisserie (en nombre) 2024']\n            )\n        )\n\n\n\n\nVilles-fantômes\nQuelles sont les villes ne comportant aucun habitant ? Pourquoi ?\n\n# Entrez ici votre code\n\n\n\nSolution\nvilles_mortes = [ \n    v for v in communes \n    if v['Population municipale 2022'] == 0\n]\n\nprint(\"Villes sans habitants :\")\n\n# Ce sont toutes des communes de la Meuse, non loin de Verdun : \n# souvenir de la Grande Guerre...\n\nfor v in villes_mortes: \n    print(\"- {} ({})\".format(v['Libellé'], v['Code']))\n\n\n\n\nHabitants de caractères\nQuelles communes ont autant d’habitants que de caractères dans leur nom ?\n\n# Entrez ici votre code\n\n\n\nSolution\nvilles_lettres = [ \n    v for v in communes \n    if len(v['Libellé']) == v['Population municipale 2022']\n]\n\nprint(\"Villes qui ont autant d'habitants que de lettres dans leur nom :\")\n\nfor v in villes_lettres: \n    print(\"- {} ({}) : {} habitants, {} caractères\".format(\n        v['Libellé'], \n        v['Code'],\n        v['Population municipale 2022'],\n        len(v['Libellé'])\n        )\n    )\n\n\n\n\nDu pain, du pain\nCombien y a-t-il de boulangeries en France ? Quelle est la commune qui a la plus forte densité de boulangeries parmi les villes de plus de 5000 habitants ?\n\n# Entrez ici votre code\n\n\n\nSolution\nnb_boul = sum([c['Boulangerie-pâtisserie (en nombre) 2024'] for c in communes])\n\nprint(\"Boulangeries-pâtisseries en France en 2024 : {}\".format(nb_boul))\n\ndensite_max = 0\nlaureat = ''\n\nfor com in communes:\n    boulang    = com['Boulangerie-pâtisserie (en nombre) 2024']\n    population = com['Population municipale 2022']\n    \n    if population &gt; 5000 and boulang/population*1000 &gt; densite_max:\n        densite_max = boulang/population*1000\n        laureat = com['Libellé']\n\nprint(\"Ville à la plus forte densité : {} ({:.1f} boulangeries/1000 hab)\".format(\n    laureat, \n    densite_max\n    )\n)\n\n\n\n\nEssartage\nQuelles communes contiennent le toponyme ‘essart’ dans leur nom ?\n\n# Entrez ici votre code\n\n\n\nSolution\nessarts = []\n\nfor com in communes:\n    if 'essart' in com['Libellé'].lower():\n        essarts.append(com)\n\nprint(\"Villes avec le toponyme Essart :\")\n\nfor v in essarts:\n    print(\"- {name} ({code})\".format(code=v['Code'], name=v['Libellé']))\n\n\n\n\nChef-lieu chétif\nDans quels départements le chef-lieu n’est-il pas la commune la plus peuplée ? Quelles sont les communes plus peuplées ?\nIndice : on commencera par créer un dictionnaire associant à chaque chef-lieu sa population municipale.\n\n## Entrez ici votre code\n\n\n\nSolution\ndico_cheflieu = {}\nresultats = {}\n\n# Création du dictionnaire qui associe le code d'un chef-lieu à sa population\nfor d in depts:\n    code = d['CHEFLIEU']\n    for c in communes:\n        if code == c['Code']:\n            dico_cheflieu[code] = c['Population municipale 2022']\n\n# Examen de chacune des communes\nfor c in communes:\n    code_insee  = c['Code']\n    population  = c['Population municipale 2022']\n    departement = 'XX'\n    \n    # On récupère le département : \n    # les trois premiers chiffres du code INSEE en outre-mer,\n    # les deux premiers chiffres sinon \n    if code_insee.startswith('97'):\n        departement = code_insee[:3]\n    else:\n        departement = code_insee[:2]\n    \n    # Quel est le chef-lieu de ce département ?\n    chl = '0000'\n    for d in depts:\n        if d['DEP'] == departement:\n            chl = d['CHEFLIEU']\n    \n    # On compare la population de la commune à celle du chef-lieu\n    if population &gt; dico_cheflieu[chl]:\n        # Si le département n'est pas déjà dans le dictionnaire, on l'ajoute\n        if departement not in resultats:\n            resultats[departement] = []\n        # Et on ajoute la ville à la liste\n        resultats[departement].append(c['Libellé'])\n\nprint(\"Départements comptant au moins une ville plus peuplée que le chef-lieu :\")\nfor k, v in sorted(resultats.items()):\n    print(\"- {} : \".format(k), end='')\n    print(', '.join(v))\n\n\n\n\nNom commun\nQuels sont les dix noms de ville le plus répandu ? (ie. ceux que le plus grand nombre de communes portent) ?\n\n# Entrez ici votre code\n\n\n\nSolution\ndico_noms = {}\n\nfor c in communes:\n    nom = c['Libellé'].upper()\n    if nom in dico_noms:\n        dico_noms[nom]+=1\n    else:\n        dico_noms[nom]=1\n\ntop10 = sorted(dico_noms.items(), key=lambda x: x[1], reverse=True)[:10]\n\nprint('Top 10 des noms les plus répandus : ')\nfor ville, occurence in top10:\n    print('- {} ({})'.format(ville, occurence))",
    "crumbs": [
      "Premiers pas en CSV"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html",
    "href": "chapters/qgis-intro.html",
    "title": "Introduction à QGIS",
    "section": "",
    "text": "Nous allons créer sans attendre notre première carte : un fond de plan cartographique centré sur la CA Paris Vallée de la Marne, sur lequel nous allons superposer des couches vectorielles de description administrative du territoire.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#création-du-projet",
    "href": "chapters/qgis-intro.html#création-du-projet",
    "title": "Introduction à QGIS",
    "section": "Création du projet",
    "text": "Création du projet\nLancer QGIS, créer un nouveau projet.\n\nProjet → Nouveau",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#ajout-dun-fond-de-carte",
    "href": "chapters/qgis-intro.html#ajout-dun-fond-de-carte",
    "title": "Introduction à QGIS",
    "section": "Ajout d’un fond de carte",
    "text": "Ajout d’un fond de carte\nAjouter le fond de carte OpenStreetMap.\n\nCouche → Ajouter une couche → Ajouter une couche XYZ\nConnexions XYZ → OpenStreetMap\nAjouter\n\nDans le coin inférieur droit, remarquez qu’un SCR a été automatiquement défini : EPSG:3857. C’est celui de la première couche ajoutée. Si nous devions ajouter des couches exprimées dans un autre SCR, QGIS ferait la conversion de manière transparente, à condition qu’il puisse déterminer sans ambiguité le SCR de la couche fournie.\n\n\nSCR, Késako ?\n\nUn système de coordonnées de référence est le référentiel qui donne du sens aux valeurs numériques que prennent des coordonnées géographiques (latitude, longitude, altitude). On pourra se référer utilement à la documentation. de QGIS.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#ajout-dune-première-couche-vectorielle",
    "href": "chapters/qgis-intro.html#ajout-dune-première-couche-vectorielle",
    "title": "Introduction à QGIS",
    "section": "Ajout d’une première couche vectorielle",
    "text": "Ajout d’une première couche vectorielle\nTélécharger la géodatabase préparée spécialement pour ce TP. Elle contient quelques données issues de la base AdminExpress de l’IGN.\n\n\nGéodatabase, ESRI Shapefile ?\n\nPlusieurs formats existent pour stocker de l’information géographique. QGIS travaille par défaut avec des géodatabases. Vous trouverez souvent des fichiers au format ESRI Shapefile. On retiendra qu’une géodatabase (extension gpkg) est capable de stocker plusieurs couches dans un même fichier, alors que le format ESRI Shapefile (extension principale shp) crée six différents fichiers pour stocker l’information d’une seule couche vectorielle. Pour les détails techniques, se référer à la documentation.\n\nAjouter la couche communes contenue dans la Géodatabase.\n\nCouche → Ajouter une couche → Ajouter une couche vecteur\nSource → Jeux de données vectorielles\nAller chercher le ficher ade_simplifie.gpkg\nDans la fenêtre qui s’affiche, sélectionner la couche commune\n\n\nOn va modifier la symbologie de la couche pour ne conserver que les contours de chaque objet, sans ce vilain fond opaque, puis ajouter des étiquettes donnant le nom de la commune (on pourra personnaliser la police et le corps).\nAvec la couche sélectionnée :\n\nCouche → Propriétés de la couche\nSymbologie → Remplissage simple → Style de remplissage → Pas de remplissage\nÉtiquettes → Étiquettes simples → Valeur → nom_officiel",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#transparence-du-fond-de-plan",
    "href": "chapters/qgis-intro.html#transparence-du-fond-de-plan",
    "title": "Introduction à QGIS",
    "section": "Transparence du fond de plan",
    "text": "Transparence du fond de plan\nPour mieux voir nos entités vectorielles, on peut rendre le fond de plan transparent et le passer en niveau de gris.\nAvec la couche sélectionnée :\n\nCouche → Propriétés de la couche\nTransparence → Opacité globale → 50%\nSymbologie → Rendu de couche → Niveaux de gris → [Par clarté]",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#exploration-des-données",
    "href": "chapters/qgis-intro.html#exploration-des-données",
    "title": "Introduction à QGIS",
    "section": "Exploration des données",
    "text": "Exploration des données\nÀ chaque objet de la couche communes correspondent des données. On peut les afficher pour un objet donné avec l’outil Identifier des données accessible par la barre d’outils. Pour les communes, un champ important est le code_insee. C’est lui qui identifie la commune de manière unique, on en aura besoin ultérieurement.\n\n\nDe l’importance des métadonnées\n\nMême si les intitulés des champs sont ici clairs, il est de bonne pratique de toujours consulter les métadonnées d’une source de données pour s’assurer d’avoir bien tout compris. Dans le cas présent, on ira voir sur le site de l’IGN, à la page ADMIN Express.\n\n\nUne autre manière d’explorer la couche est d’afficher sa table d’attributs (F6).\n\nCouche → Ouvrir la table d’attributs",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#sélection-manuelle-de-données",
    "href": "chapters/qgis-intro.html#sélection-manuelle-de-données",
    "title": "Introduction à QGIS",
    "section": "Sélection manuelle de données",
    "text": "Sélection manuelle de données\nOn peut sélectionner manuellement une ou plusieurs entités à l’aide de l’outil de la barre des tâches.\nNoter dans le menu déroulant les modes de sélections possibles: rectangle de sélection, polygone, main levée, par rayon.\nNoter les raccourcis-claviers utiles. Pour ajouter des objets à la sélection courante, maintenir SHIFT. Pour retrancher des objets à la sélection courante, maintenir CTRL.\nSélectionner les trois communes de Champs-sur-Marne, Noisiel et Émerainville.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#statistiques-descriptives",
    "href": "chapters/qgis-intro.html#statistiques-descriptives",
    "title": "Introduction à QGIS",
    "section": "Statistiques descriptives",
    "text": "Statistiques descriptives\nOn peut calculer aisément certains agrégats (moyenne, médiane, etc.) sur les attributs des entités sélectionnés.\n\nVue → Résumé statistique\n\n\n\nQuelle est la population totale de ces trois communes ?\n\n50 124 habitants (au 1er janvier 2022).\n\n\n\nQuelle est la superficie cadastrale totale de ces trois communes ?\n\n1 710 hectares.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#premiers-calculs-géométriques",
    "href": "chapters/qgis-intro.html#premiers-calculs-géométriques",
    "title": "Introduction à QGIS",
    "section": "Premiers calculs géométriques",
    "text": "Premiers calculs géométriques\nUn SIG est capable de calculer la superficie de chaque polygone. On va vérifier que la superficie calculée est cohérente avec la superficie cadastrale renseignée dans la table attributaire.\nOuvrir la table d’attributs (F6), puis la calculatrice de champs (bouton en forme de boulier dans la barre d’outils, également CTRL+I).\nDans la fenêtre qui s’ouvre : * Indiquer le nom du champ à créer (on peut l’appeler superficie) * Sélectionner la case champ virtuel (ie. le champ ne sera pas persistent) * Indiquer le type du champ (entier) * Renseigner la formule pour calculer le champ : area(@geometry) * Valider\n\n\nQuelle sera l’unité du champ superficie ?\n\nIl dépend bien sûr de l’unité employée par le SCR de la carte. Pour le nôtre, c’est le mètre. Le champ superficie sera donc exprimé en mètres-carrés. On pourra diviser par 10000 pour le convertir en hectares.\n\n\nLe champ superficie figure bien désormais dans la table attributaire. On peut calculer la superficie des trois communes de la même manière qu’on a calculé celle de la population.\n\n\nQuelle est la superficie calculée totale de ces trois communes ?\n\n1 737,29 ha. L’écart est de 17,29 ha avec la superficie cadastrale, marge &lt;1%.\n\nOn peut également utiliser l’outil de mesure de longueur (CTRL+ALT+M) ou d’aires (CTRL+ALT+J) pour des calculs ponctuels sur la carte.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#affichage-par-catégories",
    "href": "chapters/qgis-intro.html#affichage-par-catégories",
    "title": "Introduction à QGIS",
    "section": "Affichage par catégories",
    "text": "Affichage par catégories\nOn va désormais colorer les communes différemment en fonction de l’EPCI auquel elles appartiennent.\n\nCouche → Propriétés de la couche → Symbologie → [catégorisé]\nValeur → [codes_siren_des_epci]\nSymboles → Remplissage simple → Style de remplissage → [continue]\nBouton Classer\nBouton Appliquer\n\nOn voit nettement se dessiner les 7 EPCI présents dans la base.\n\n\n\nMillefeuille administratif ?\n\nVous noterez dans la légende que le champ codes_siren_des_epci contient parfois deux numéros SIREN : certaines communes appartient bien à deux EPCI en même temps (Métropole du Grand Paris + EPT).",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#sélection-avancée-de-données",
    "href": "chapters/qgis-intro.html#sélection-avancée-de-données",
    "title": "Introduction à QGIS",
    "section": "Sélection avancée de données",
    "text": "Sélection avancée de données\nOn va désormais sélectionner toutes les communes appartenant à la CA Paris Vallée de la Marne en testant deux méthodes.\n\nSélection par attributs\nOn peut sélectionner l’ensemble des entités de la couche des communes dont le champ code_siren_des_epci contient la valeur 200057958 grâce à la sélection par expression (CTRL+F3)\n\nÉditer → Sélection → Sélectionner des entités à l’aide d’une sélection\nExpression → [“codes_siren_des_epci” = ‘200057958’]\n\n\n\n\nSélection par géométrie\nOn peut aussi sélectionner l’ensemble des entités de la couche des communes qui sont situées à l’intérieur du polygone représentant la CA Paris Vallée de la Marne dans la couche des EPCI.\nPour cela, on va ajouter la couche vectorielle des EPCI qui figure dans la même géodatabase que la couche des communes et lui appliquer le style qui convient. Pour cela, se référer au début du TD.\nSélectionner ensuite le polygone représentant la CA Paris Vallée de la Marne.\n\nVecteur → Outils de recherche → Sélection par localisation\nSélectionner les entités depuis → ade_simplifiee - communes\nOù les entités → est à l'intérieur\nEn comparant les entité de → ade_simplifiee - epci\ncocher la case entités sélectionnées uniquement",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#export-vers-une-nouvelle-couche",
    "href": "chapters/qgis-intro.html#export-vers-une-nouvelle-couche",
    "title": "Introduction à QGIS",
    "section": "Export vers une nouvelle couche",
    "text": "Export vers une nouvelle couche\nCréons maintenant un couche contenant uniquement les 12 communes de la CA Paris Vallée de la Marne. On sauvegardera cette couche dans notre géodatabase initiale.\n\nPanneau des couches →  clic-droit couche communes\nExporter → Sauvegarder les entités sélectionnées sous",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#jointure-attributaire",
    "href": "chapters/qgis-intro.html#jointure-attributaire",
    "title": "Introduction à QGIS",
    "section": "Jointure attributaire",
    "text": "Jointure attributaire\nReprésentons désormais les différences de population entre les communes.\nOn serait tenté de faire varier les couleurs des polygones du plus clair au plus foncé : les géomaticiens appellent ces cartes des cartes teintées, ou cartes choroplèthes. Mais pas de choroplèthes avec des données stock… on fera donc varier la taille de points représentant les communes.\nDans la géodatabase initiale, charger la couche chef_lieu_de_commune. Elle contient un semis de points, un pour chaque chef-lieu (c’est-à-dire la mairie).\nOuvrir la table attributaire : constater qu’il y a bien un champ code_insee_de_la_commune, mais pas (encore) de champ population… Qu’à cela ne tienne : on va l’ajouter, en joignant la table des chefs-lieux des communes à celle des communes.\nAvec la couche des chefs-lieux sélectionnés :\n\nCouche → Propriétés de la couche → Jointures\nCliquer le bouton +\nJoindre la couche → ade_simplifiee - communes, ade_simplifie\nChamp de jointure → code_insee\nChamp dans la couche cible → code_insee_de_la_commune\nChamps joints → population",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#affichage-gradué",
    "href": "chapters/qgis-intro.html#affichage-gradué",
    "title": "Introduction à QGIS",
    "section": "Affichage gradué",
    "text": "Affichage gradué\nOn peut désormais modifier la symbologie et faire varier la taille des points en fonction de la valeur du champ population.\n\nCouche → Propriétés de la couche → Symbologie\nSélectionner gradué\nValeur → xxx_population\nMéthode → Taille\nMode → intervalle égal\n\n\n\nDiscrétisation\n\nOn comprend bien que le choix des seuils, du nombre de catégories, etc. est stratégique, et qu’on peut faire dire à des mêmes données des choses très différentes selon les choix opérés…",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#mise-en-page-et-export",
    "href": "chapters/qgis-intro.html#mise-en-page-et-export",
    "title": "Introduction à QGIS",
    "section": "Mise en page et export",
    "text": "Mise en page et export\nExportons notre carte en PDF. Il faut pour cela créer une mise en page.\n\nProjet → Nouvelle mise en page\n\nDans la fenêtre qui s’ouvre : * Insérer un bloc carte * Insérer un bloc de texte pour le titre * Insérer un bloc légende * Insérer une échelle graphique * Insérer une flèche indiquant le nord * …\nUne fois tous les paramètres ajustés, exporter la carte en PDF.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  }
]