[
  {
    "objectID": "chapters/outils-quotidiens.html",
    "href": "chapters/outils-quotidiens.html",
    "title": "Les outils du quotidien",
    "section": "",
    "text": "En informatique, de nombreux logiciels libres et gratuits existent. Il répondent efficacement aux besoins de la vie courante et sont souvent bien meilleurs que les outils intégrés à Windows ou Mac OS.\nVoici quelques propositions. On pourra également se référer au catalogue publié par l’État des logiciels libres recommandés pour l’administration.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#compressiondécompression",
    "href": "chapters/outils-quotidiens.html#compressiondécompression",
    "title": "Les outils du quotidien",
    "section": "Compression/décompression",
    "text": "Compression/décompression\nRéduire le volume des données avant de les stocker ou de les transférer. Quelques formats usuels : zip, rar, 7z, tar.gz…\n\n7z, capable de traiter une grande variété de formats.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#visualisation-dimages",
    "href": "chapters/outils-quotidiens.html#visualisation-dimages",
    "title": "Les outils du quotidien",
    "section": "Visualisation d’images",
    "text": "Visualisation d’images\nNaviguer rapidement dans une série d’images.\n\nNomacs, existe en version portable.\nIrfanview, un visualisateur très léger.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#capture-décran",
    "href": "chapters/outils-quotidiens.html#capture-décran",
    "title": "Les outils du quotidien",
    "section": "Capture d’écran",
    "text": "Capture d’écran\nSauvegarder tout ou partie de son écran, en annotant rapidement ce que l’on voit.\n\nGreenshot, pour Windows.\nFlameshot, multi-plateformes.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#retouche-dimages",
    "href": "chapters/outils-quotidiens.html#retouche-dimages",
    "title": "Les outils du quotidien",
    "section": "Retouche d’images",
    "text": "Retouche d’images\nModifier des images raster : recadrer, redimensionner, ajuster les couleurs, etc.\n\nGimp, aussi efficace que Photoshop pour les besoins courants.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#dessin",
    "href": "chapters/outils-quotidiens.html#dessin",
    "title": "Les outils du quotidien",
    "section": "Dessin",
    "text": "Dessin\nDessiner en vectoriel (ex. repérer une parcelle sur une photo, ajouter des textes, etc.) plus proprement qu’en utilisant Paint ou Powerpoint.\n\nInkscape",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#éditeur-de-texte",
    "href": "chapters/outils-quotidiens.html#éditeur-de-texte",
    "title": "Les outils du quotidien",
    "section": "Éditeur de texte",
    "text": "Éditeur de texte\nÉditer du texte brut (ie. sans mise en forme), avec des fonctionnalités avancées : coloration syntaxique, expressions régulières, etc.\n\nNotepad++, très complet.\nNotepad2, simple et efficace au quotidien.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#visionneuse-de-pdf",
    "href": "chapters/outils-quotidiens.html#visionneuse-de-pdf",
    "title": "Les outils du quotidien",
    "section": "Visionneuse de PDF",
    "text": "Visionneuse de PDF\nOuvrir rapidement des fichiers PDF.\n\nSumatra PDF, beaucoup plus léger qu’Acrobat Reader.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#édition-de-pdf",
    "href": "chapters/outils-quotidiens.html#édition-de-pdf",
    "title": "Les outils du quotidien",
    "section": "Édition de PDF",
    "text": "Édition de PDF\nDécouper ou fusionner des fichiers PDF.\n\nPDF Sam Basic",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/outils-quotidiens.html#cartographie",
    "href": "chapters/outils-quotidiens.html#cartographie",
    "title": "Les outils du quotidien",
    "section": "Cartographie",
    "text": "Cartographie\nFaire des cartes simples ou complexes.\n\nQGIS, client de référence, application de bureau.\nuMap, service en ligne pour des cartes simples et rapides.\nMagrit, un outil de cartographie thématique simple et intuitif développé par le CNRS.",
    "crumbs": [
      "Les outils du quotidien"
    ]
  },
  {
    "objectID": "chapters/chapter1.html",
    "href": "chapters/chapter1.html",
    "title": "Traitement de fichiers CSV",
    "section": "",
    "text": "Dans ce TD, nous allons apprendre à manipuler un type de fichier texte très utilisé pour stocker et diffuser des données : le CSV.\nCSV est l’abréviation de comma-separated values, soit “valeurs séparées par des virgules” – même si, bien souvent, le délimiteur standard (la virgule) est remplacée par un autre délimiteur.\nUn fichier CSV reproduit la structure d’un tableau :\nUn module de la bibliothèque standard de Python est spécialement conçu pour faciliter l’interaction avec ce type de fichiers : le module csv.\nEn pratique, on utilise souvent des modules de plus haut niveau (comme pandas) pour travailler avec des tableaux (DataFrames).\nNous allons néanmoins nous entraîner à l’utiliser en explorant deux fichiers de l’INSEE :",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#préambule",
    "href": "chapters/chapter1.html#préambule",
    "title": "Traitement de fichiers CSV",
    "section": "Préambule",
    "text": "Préambule\nCe notebook est conçu pour être interactif. Dans les cellules prévues à cet effet, vous pouvez écrire du code en Python et l’exécuter en pressant SHIFT+ENTER.\nLes variables restent en mémoire d’une cellule à l’autre. Essayez ci-dessous !\n\n# C'est à vous !",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#première-exploration-des-données",
    "href": "chapters/chapter1.html#première-exploration-des-données",
    "title": "Traitement de fichiers CSV",
    "section": "Première exploration des données",
    "text": "Première exploration des données\nAvant tout, téléchargez les fichiers source sur votre ordinateur et ouvrez-les avec un éditeur de texte brut (comme Notepad++) pour en examiner la structure.\n\nExploration de insee_data.csv\nOn note que :\n\nLe fichier est encodé en UTF-8.\nles valeurs sont séparées par des points-virgules (;).\nLa 1ère ligne du fichier contient le nom des colonnes : c’est l’entête, ou header.\nLes 34 785 autres lignes contiennent les données, une ligne par commune.\n\nOn relève qu’il y a quatre colonnes :\n\nCode : le numéro INSEE de la commune.\nLibellé : le nom de la commune.\nPopulation municipale 2022 : la population de référence de la commune, millésime 2022, entrée en vigueur le 1er janvier 2025, donnée issue du recensement de la population.\nBoulangerie-pâtisserie (en nombre) 2024 : le nombre de boulangeries-pâtisseries que comptait la commune en 2024, donnée issue de la Base Permanente des Équipements (BPE).\n\n\n\nExploration de v_departement_2025.csv\nOn note que :\n\nLe fichier est encodé en UTF-8.\nles valeurs sont séparées par des virgules (,).\nLe fichier comporte un header.\nLes 101 autres lignes contiennent les données, une ligne par département.\n\nOn relève qu’il y a sept colonnes :\n\nREGION : code région.\nDEP : code département.\nCHEFLIEU : code de la commune chef-lieu.\nTNCC : Type de nom en clair (donne une indication grammaticale).\nNCC : Nom en clair, en majuscules.\nNCCENR : Nom en clair, en minuscules accentuées.\nLIBELLE : Nom en clair, en minuscules accentuées avec article.",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#chargement-des-données",
    "href": "chapters/chapter1.html#chargement-des-données",
    "title": "Traitement de fichiers CSV",
    "section": "Chargement des données",
    "text": "Chargement des données\n\nPrincipe\nOn peut modéliser les données avec Python de plusieurs manières.\n\nListe de listes\nOn peut construire une liste de listes : la grande liste représente le tableau, elle contient plusieurs listes (autant que de lignes) dont chacun des élements représentent les valeurs des colonnes.\n\n# On importe le module CSV\nimport csv\n\n# On crée la première liste\nrows = []\n\n# On ouvre le fichier en mode lecture ('r') en spécifiant l'encodage ('utf-8'),\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n\n    # On crée un objet reader() qui lit une ligne du fichier qui lui est passé,\n    # détecte les délimiteurs et renvoie la liste des champs qu'ils séparent \n    csv_reader = csv.reader(mf, delimiter=';')\n\n    # Cet objet est conçu comme un itérateur : à chaque fois qu'on l'appelle,\n    # il passe à la ligne suivante, jusqu'à la fin du fichier. \n    # On stocke ainsi toutes les listes renvoyées dans la première liste.\n    for row in csv_reader:\n        rows.append(row)\n\n# On affiche la valeur stockée 13e ligne, 2eme colonne\n# (pour mémoire, Python compte à partir de 0) :\nprint('La valeur à la 13e ligne, 2eme colonne est la suivante : ', end=None)\nprint(rows[12][1])\n\n\n\nListe de dictionnaires\nMais puisque notre fichier comporte un entête, il est intéressant de modéliser les données sous la forme d’une liste de dictionnaires : chaque ligne sera représentée par un dictionnaire qui fait correspondre aux noms des colonnes (ex: Code) leurs valeurs (ex: '01001').\nPour montrer l’intérêt, on ne conservera ici que les communes dont le champ Code commence par '77' (c’est-à-dire les communes de Seine-et-Marne).\n\n# On crée une autre liste\nseinemarne = []\n\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n   \n    # On utilise ici un objet DictReader()\n    csv_reader = csv.DictReader(mf, delimiter=';')\n    \n    # Les objets renvoyés à chaque appel sont donc des dictionnaires\n    for dico in csv_reader:\n        \n        # On utilise la méthode `startswith` dont disposent les objets de type \n        # natif `str` pour filtrer les éléments qui nous intéressent\n        if dico['Code'].startswith('77'):\n            seinemarne.append(dico)\n\n# On affiche le libellé du dernier élément de la liste ainsi constituée\nlibelle = seinemarne[-1]['Libellé']\nprint(\"La dernière ville de la liste est : {}\".format(libelle))\n\n\n\n\nÀ vous de jouer !\n\nChargement de insee_data.csv\nChargez les données du fichier insee_data.csvdans une liste de dictionnaires que vous nommerez communes.\nAffichez le nom et la population de la 10 000e ville de la liste.\n\n# Entrez ici votre code\n\n\n\nSolution\ncommunes = []\n\nwith open('data/insee_data.csv', 'r', encoding='utf-8') as mf:\n    csv_reader = csv.DictReader(mf, delimiter=';')\n    for row in csv_reader:\n        communes.append(row)\n\n\nprint(\"La 10000e ville de la liste est : {}, {} habitants.\".format(\n    communes[9999]['Libellé'],\n    communes[9999]['Population municipale 2022']\n    )\n)\n\n\n\n\nChargement de v_departement_2025.csv\nChargez les données du fichier v_departement_2025.csv dans une liste de dictionnaires que vous nommerez depts.\nAffichez le nom en majuscule du 17e département de la liste.\n\n# Entrez ici votre code\n\n\n\nSolution\ndepts = []\n\nwith open('data/v_departement_2025.csv', 'r', encoding='utf-8') as mf:\n    csv_reader = csv.DictReader(mf, delimiter=',')\n    for row in csv_reader:\n        depts.append(row)\n\nprint(\"Le 17eme département de la liste est : {}.\".format(depts[16]['NCC']))",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#vérification-et-nettoyage-des-données",
    "href": "chapters/chapter1.html#vérification-et-nettoyage-des-données",
    "title": "Traitement de fichiers CSV",
    "section": "Vérification et nettoyage des données",
    "text": "Vérification et nettoyage des données\nIl est utile de vérifier que les données ne présentent pas de “bizarreries” (éléments aberrants, valeurs manquantes, etc.).\nNous allons conduire quelques tests de cohérence.\n\nNombre de champs pour chaque enregistrement\nOn va s’assurer que chaque enregistrement des listes communes et depts comporte le bon nombre de champs : 4 pour les communes, 7 pour les départements.\nÉcrivez un programme qui vérifie pour les deux listes que chaque dictionnaire contient le nombre approprié de clés. On stockera dans des listes à part les problèmes éventuels (si tout va bien, ces listes seront vides).\n\n# Entrez ici votre code\n\n\n\nSolution\n# Pour les communes tout d'abord\n# On le fait de façon naïve, avec une boucle traditionnelle\ncommunes_avec_pb = []\nfor com in communes:\n    if len(com) != 4:\n        communes_avec_pb.append(com)\n\nprint(\"{} enregistrements problématiques dans la liste 'communes'\".format(\n    len(communes_avec_pb)\n    )\n)\n\n# Pour les départements ensuite\n# On le fait e façon pythonique, avec une compréhension de liste\ndept_avec_pb = [dep for dep in depts if len(dep) != 7]\n\nprint(\"{} enregistrements problématiques dans la liste 'dept'\".format(\n    len(dept_avec_pb)\n    )\n)\n\n\n\n\nCohérence géographique\nDans la liste depts, on va vérifier que la commune désignée comme chef-lieu d’un département appartient bien à ce département.\nOn se souviendra que le code INSEE d’une commune commence par le numéro du département auquel elle appartient, codé sur 2 caractères (3 pour l’outre-mer).\n\n# Entrez ici votre code\n\n\n\nSolution\n# Voici la façon naïve, avec une boucle traditionnelle\npb_chef_lieu = []\nfor dep in depts:\n    codeinsee = dep['CHEFLIEU']\n    if codeinsee[:2] != dep['DEP'] and codeinsee[:3] != dep['DEP']:\n        pb_chef_lieu.append(dep)\n\npb_chef_lieu\n\n# Et la même chose de façon pythonique, avec une compréhension de liste\npb_chef_lieu = [ \n    dep for depts in depts \n    if  dep['CHEFLIEU'][:2] != dep['DEP']\n    and dep['CHEFLIEU'][:3] != dep['DEP']\n]\n\nprint(\"{} communes situées hors du département.\".format(len(pb_chef_lieu)))\n\n\n\n\nValeurs manquantes\nBien souvent, les données manquantes dans une série de données sont signalées par une chaîne de caractère spécifique (comme N/A) et non par l’absence de valeurs. Cela peut-être gênant.\nDans la table communes, on va ainsi filtrer les enregistrements qui contiennent des valeurs non numériques dans les champs de données.\nOn utilisera pour cela la méthode is_decimal dont disposent les objets de type natif str (cf documentation). Cette méthode renvoie True si tous les caractères d’une chaîne sont des caractères décimaux et qu’elle contient au moins un caractère, False sinon.\n\n# Entrez ici votre code\n\n\n\nSolution\n# Voici la façon naïve, avec une boucle traditionnelle\npb_nombre = []\nfor com in communes:\n    if not com['Population municipale 2022'].isdecimal():\n        pb_nombre.append(com)\n        next\n    elif not com['Boulangerie-pâtisserie (en nombre) 2024'].isdecimal():\n        pb_nombre.append(com)\n\n\n# Et la même chose de façon pythonique, avec une compréhension de liste\npb_nombre = [\n    com for com in communes\n    if not com['Population municipale 2022'].isdecimal()\n    or not com['Boulangerie-pâtisserie (en nombre) 2024'].isdecimal()\n]\n\nprint(\"{} communes avec données manquantes.\".format(len(pb_nombre)))\n\n\nAinsi donc, des données sont manquantes pour une vingtaine de communes… On les éliminera de la liste communes.\n\n# Entrez ici votre code\n\n\n\nSolution\nprint(\"Nombre d'enregistrements avant nettoyage : {}\".format(len(communes)))\n\nfor ville in pb_nombre:\n    communes.remove(ville)\n\nprint(\"Nombre d'enregistrements après nettoyage : {}\".format(len(communes)))\n\n\n\n\nGestion des types\nDans la liste communes, les valeurs stockées dans les champs de données sont pour l’instant représentées par des chaînes de caractères.\n\nprint(type(communes[0]['Population municipale 2022']))\n\nPour les utiliser dans des calculs, il faut d’abord les convertir en nombres entiers. Allez-y !\n\n# Entrez ici votre code\n\n\n\nSolution\nfor c in communes:\n    for champ in ['Population municipale 2022', 'Boulangerie-pâtisserie (en nombre) 2024']:\n        c[champ] = int(c[champ])\n\nprint(type(communes[0]['Population municipale 2022']))",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "chapters/chapter1.html#requêtes-sur-les-données",
    "href": "chapters/chapter1.html#requêtes-sur-les-données",
    "title": "Traitement de fichiers CSV",
    "section": "Requêtes sur les données",
    "text": "Requêtes sur les données\nUtilisez les deux tables communes et depts construites précédemment pour répondre aux questions suivantes.\n\nBoulangeries de(s) Champs\nCombien y a-t-il de boulangeries à Champs-sur-Marne (77083) ?\n\n# Entrez ici votre code\n\n\n\nSolution\nfor c in communes:\n    if c['Code'] == '77083':\n        print(\"{} : {} boulangeries\".format(\n            c['Libellé'],\n            c['Boulangerie-pâtisserie (en nombre) 2024']\n            )\n        )\n\n\n\n\nVilles-fantômes\nQuelles sont les villes ne comportant aucun habitant ? Pourquoi ?\n\n# Entrez ici votre code\n\n\n\nSolution\nvilles_mortes = [ \n    v for v in communes \n    if v['Population municipale 2022'] == 0\n]\n\nprint(\"Villes sans habitants :\")\n\n# Ce sont toutes des communes de la Meuse, non loin de Verdun : \n# souvenir de la Grande Guerre...\n\nfor v in villes_mortes: \n    print(\"- {} ({})\".format(v['Libellé'], v['Code']))\n\n\n\n\nHabitants de caractères\nQuelles communes ont autant d’habitants que de caractères dans leur nom ?\n\n# Entrez ici votre code\n\n\n\nSolution\nvilles_lettres = [ \n    v for v in communes \n    if len(v['Libellé']) == v['Population municipale 2022']\n]\n\nprint(\"Villes qui ont autant d'habitants que de lettres dans leur nom :\")\n\nfor v in villes_lettres: \n    print(\"- {} ({}) : {} habitants, {} caractères\".format(\n        v['Libellé'], \n        v['Code'],\n        v['Population municipale 2022'],\n        len(v['Libellé'])\n        )\n    )\n\n\n\n\nDu pain, du pain\nCombien y a-t-il de boulangeries en France ? Quelle est la commune qui a la plus forte densité de boulangeries parmi les villes de plus de 5000 habitants ?\n\n# Entrez ici votre code\n\n\n\nSolution\nnb_boul = sum([c['Boulangerie-pâtisserie (en nombre) 2024'] for c in communes])\n\nprint(\"Boulangeries-pâtisseries en France en 2024 : {}\".format(nb_boul))\n\ndensite_max = 0\nlaureat = ''\n\nfor com in communes:\n    boulang    = com['Boulangerie-pâtisserie (en nombre) 2024']\n    population = com['Population municipale 2022']\n    \n    if population &gt; 5000 and boulang/population*1000 &gt; densite_max:\n        densite_max = boulang/population*1000\n        laureat = com['Libellé']\n\nprint(\"Ville à la plus forte densité : {} ({:.1f} boulangeries/1000 hab)\".format(\n    laureat, \n    densite_max\n    )\n)\n\n\n\n\nEssartage\nQuelles communes contiennent le toponyme ‘essart’ dans leur nom ?\n\n# Entrez ici votre code\n\n\n\nSolution\nessarts = []\n\nfor com in communes:\n    if 'essart' in com['Libellé'].lower():\n        essarts.append(com)\n\nprint(\"Villes avec le toponyme Essart :\")\n\nfor v in essarts:\n    print(\"- {name} ({code})\".format(code=v['Code'], name=v['Libellé']))\n\n\n\n\nChef-lieu chétif\nDans quels départements le chef-lieu n’est-il pas la commune la plus peuplée ? Quelles sont les communes plus peuplées ?\nIndice : on commencera par créer un dictionnaire associant à chaque chef-lieu sa population municipale.\n\n## Entrez ici votre code\n\n\n\nSolution\ndico_cheflieu = {}\nresultats = {}\n\n# Création du dictionnaire qui associe le code d'un chef-lieu à sa population\nfor d in depts:\n    code = d['CHEFLIEU']\n    for c in communes:\n        if code == c['Code']:\n            dico_cheflieu[code] = c['Population municipale 2022']\n\n# Examen de chacune des communes\nfor c in communes:\n    code_insee  = c['Code']\n    population  = c['Population municipale 2022']\n    departement = 'XX'\n    \n    # On récupère le département : \n    # les trois premiers chiffres du code INSEE en outre-mer,\n    # les deux premiers chiffres sinon \n    if code_insee.startswith('97'):\n        departement = code_insee[:3]\n    else:\n        departement = code_insee[:2]\n    \n    # Quel est le chef-lieu de ce département ?\n    chl = '0000'\n    for d in depts:\n        if d['DEP'] == departement:\n            chl = d['CHEFLIEU']\n    \n    # On compare la population de la commune à celle du chef-lieu\n    if population &gt; dico_cheflieu[chl]:\n        # Si le département n'est pas déjà dans le dictionnaire, on l'ajoute\n        if departement not in resultats:\n            resultats[departement] = []\n        # Et on ajoute la ville à la liste\n        resultats[departement].append(c['Libellé'])\n\nprint(\"Départements comptant au moins une ville plus peuplée que le chef-lieu :\")\nfor k, v in sorted(resultats.items()):\n    print(\"- {} : \".format(k), end='')\n    print(', '.join(v))\n\n\n\n\nNom commun\nQuels sont les dix noms de ville le plus répandu ? (ie. ceux que le plus grand nombre de communes portent) ?\n\n# Entrez ici votre code\n\n\n\nSolution\ndico_noms = {}\n\nfor c in communes:\n    nom = c['Libellé'].upper()\n    if nom in dico_noms:\n        dico_noms[nom]+=1\n    else:\n        dico_noms[nom]=1\n\ntop10 = sorted(dico_noms.items(), key=lambda x: x[1], reverse=True)[:10]\n\nprint('Top 10 des noms les plus répandus : ')\nfor ville, occurence in top10:\n    print('- {} ({})'.format(ville, occurence))",
    "crumbs": [
      "Traitement de fichiers CSV"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Travaux dirigés NTICA",
    "section": "",
    "text": "Bienvenue à vous, chers élèves AMUR de la promo 2025/2026. Vous trouverez ci-dessous les liens vers les supports pour vous aider à manipuler et cartographier des données.",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "index.html#préalable-le-ssp-cloud",
    "href": "index.html#préalable-le-ssp-cloud",
    "title": "Travaux dirigés NTICA",
    "section": "Préalable : le SSP Cloud",
    "text": "Préalable : le SSP Cloud\nCertains supports sont interactifs. En cliquant sur le bouton prévu à cet effet en haut de la page, vous pourrez les lancer dans le Datalab de la plateforme SSPCloud de l’INSEE.\nCela présente plusieurs avantages :\n\nVous n’avez ainsi rien à installer\nVous disposerez de tous les modules requis aux bonnes versions\nVous aurez accès directement aux données nécessaires\n\nIl vous faudra préalablement créer un compte gratuitement, en indiquant votre adresse email @eleves.enpc.fr.",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "index.html#les-supports",
    "href": "index.html#les-supports",
    "title": "Travaux dirigés NTICA",
    "section": "Les supports",
    "text": "Les supports\n\nLes outils du quotidien\nIntroduction à QGIS\nTraitement de fichiers CSV\nTD PLU Bioclimatique",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "chapters/plu-bioclimatique.html",
    "href": "chapters/plu-bioclimatique.html",
    "title": "TD PLU Bioclimatique",
    "section": "",
    "text": "Dans ce TD, nous allons mettre en pratique quelques compétences acquises dans les séances précédentes et en acquérir de nouvelles sur un cas d’étude : le PLU Bioclimatique parisien.\nPour mémoire, la Ville de Paris a adopté en novembre 2024 son nouveau plan local d’urbanisme. La mise en révision avait été engagée en décembre 2020. Après une phase de concertation, le Conseil de Paris avait arrêté en juin 2023 un projet de PLU, qui a fait l’objet d’une enquête publique au tout début de 2024.\nÀ cette époque, le dossier d’enquête publique consistait en une multitude de gros fichiers PDF : pas de géoportail, pas de couches SIG… Si l’on voulait exploiter les données, il fallait se débrouiller.\nNous allons voir comment !",
    "crumbs": [
      "TD PLU Bioclimatique"
    ]
  },
  {
    "objectID": "chapters/plu-bioclimatique.html#les-planches-graphiques-au-12000e",
    "href": "chapters/plu-bioclimatique.html#les-planches-graphiques-au-12000e",
    "title": "TD PLU Bioclimatique",
    "section": "Les planches graphiques au 1/2000e",
    "text": "Les planches graphiques au 1/2000e\nDans le PLU, l’une des pièces-clés est l’atlas des planches au 1/2000e. Ces cartes regroupent les règles d’urbanisme applicables sur le territoire parisien. Elles représentent une traduction graphique du règlement écrit.\nL’atlas est aujourd’hui accessible en ligne sur le site des Règles d’urbanisme de Paris.\n\nUne planche\nNotre objectif va être d’afficher une des planches dans QGIS. On pourra ainsi superposer d’autres couches pour nos analyses. Pour cela, on va télécharger l’image de la carte, la traiter et la géoréférencer.\n\nTéléchargement\nJ’ai choisi la planche D-05, qui représente une partie du 8e arrondissement.\n\nSur le site des Règles d’urbanisme de Paris, dans l’onglet Documentations, trouver le plan de repérage de l’atlas.\nCliquer sur le rectangle D-05.\nDans la pop-up qui surgit, cliquer sur Vue pour télécharger la planche au format PDF.\n\n\n\n\nTraitement\nNous avons un fichier PDF. Il nous faut le convertir au format image, puis éliminer le cartouche afin de ne conserver que la carte. On peut par exemple utiliser GIMP, ou Photoshop.\nPour aller plus vite, l’image déjà traitée est téléchargeable ici.\n\n\n\nGéoréférencement\nGéoréférencer une image, c’est associer à chacun des pixels qui la composent une coordonnée géographique. Pour cela, il suffit de donner à QGIS les coordonnées de quelques points de contrôle (aussi appelés points d’appuis). Il se charge d’interpoler tous les autres.\n\nCouche de référence\nLa qualité du géoréférencement dépend donc en grande partie du choix des points de contrôle. Pour être le plus précis possible, on va charger dans QGIS l’une des couches utilisée par l’Atelier parisien d’urbanisme (APUR) pour établir les cartes du PLU : la couche de l’emprise bâtie de Paris.\nCe sera l’occasion d’apprendre comment utiliser des géoservices, c’est-à-dire des flux de données sans téléchargement préalable, puisque l’APUR utilise ArcGIS Server.\n\nCréer un projet vide dans QGIS\nSélectionner le SCR 2154 (RGF93v1 / Lambert-93)\nCouche &gt; Ajouter une couche de serveur ArcGIS REST\nURL du serveur : https://carto2.apur.org/apur/rest/services/OPENDATA/\n\n\nDans la liste des couches qui s’affiche, trouver EMPRISE_BATIE_PARIS et ajouter le 2e Période de construction. C’est un flux image et non un flux vectoriel, cela se chargera plus rapidement.\n\n\n\nGéocodage\nOuvrir l’outil de géoréférencement :\n\nCouche &gt; Géoréférencer\n\nPuis, dans la nouvelle fenêtre qui s’ouvre :\n\nFichier &gt; Ouvrir un raster\nChoisir le fichier D_05.jpg\n\nOn définit ensuite les paramètres de la transformation.\nOn conservera les paramètres proposés par défaut :\n\nType de transformation : Linéaire\nMode de ré-échantillonnage : Plus proche voisin\n\nMais on cochera la case Créer seulement un fichier World.\nTraduction : le fichier que l’on a est très propre, l’image n’a pas été déformée, la projection source est très certainement la même que la projection cible = on a seulement besoin de réduire/agrandir, tourner, translater l’image et non de la tordre pour l’ajuster.\n\nPuis, avec l’outil prévu à cet effet, sélectionner des points de contrôle, en cliquant successivement sur un point de l’image puis le même point sur la carte. On peut ici se contenter de trois points non alignés et distants les uns des autres. À partir de 3 points, QGIS calcule les erreurs de géoréférencement : en règle générale, il est bon d’avoir des écarts inférieurs à 10 pixels.\n\nLes points de contrôles utilisés dans l’image ci-dessous sont téléchargeables ici. On peut les charger si on le souhaite.\nAppliquer ensuite la transformation. La carte s’affiche à son emplacement dans Paris, on peut vérifier la qualité du géoréférencement en affichant notre couche de référence et en appliquant une légère transparence à l’image recalée.\n\n\n\nFichier World\nPar curiosité, et parce que cela nous sera utile plus tard, allons voir dans le dossier contenant l’image D_05.jpg. On remarque qu’un nouveau fichier a été créé : D_05.wld. C’est en lisant ce fichier que QGIS est capable de transformer la coordonnée d’un pixel de l’image (ex : 234, 545) en une coordonnée géographique (ex: 647 770, 6 864 143).\nOn peut ouvrir ce fichier avec un éditeur de texte.\n\nOn retiendra :\n\nque les valeurs A et D sont des facteurs d’échelle, c’est-à-dire qu’ils donnent la taille d’un pixel dans les unités du SCR utilisé. Dans notre cas, 1 pixel sur l’image = 0,169 m dans la réalité.\nque les valeurs B et C sont des termes de rotation. Dans notre cas, l’image n’a pas besoin d’être pivotée, elle est bien au nord, les termes sont donc nuls.\nque les valeurs E et F sont des termes de translation, c’est-à-dire qu’ils donnent la coordonnée géographique du point supérieur gauche de la carte. On peut le vérifier sur l’image ci-dessous.\n\nPour les gory details, se référer à cette page.\n\n\n\n\n\nPlein de planches\nNous avons traité une seule planche. Comment pourrait-on procéder si l’on voulait géoréférencer toutes les planches du PLU ? Il y a heureusement des solutions pour automatiser ce qu’on vient de faire manuellement, on va les esquisser ci-dessous.\n\nTéléchargement\nOn voit sur le site du PLU qu’un fichier avec la liste des planches est disponible.\nC’est un fichier PDF qui contient les liens vers chacune des 134 planches. Problème : ils ne sont pas apparents… On doit donc les extraire.\n\nSolution sans code : extraction avec un utilitaire en ligne comme Supertool.\nSolution avec code : extraction avec un mini script qui utilise la libraire PyMuPDF.\n\n\nimport pymupdf\n\ndoc = pymupdf.open('Consultation_des_planches_au_1_sur_2000.pdf')\n\nfor page in doc:\n   for link in page.get_links():\n       url = link['uri']\n       # Do something with url\n\nVoici un fichier texte avec la liste des liens extraits. Mais on voit qu’ils sont cassés : le prestataire IT de la Ville de Paris (dont le nom figure dans les métadonnées du PDF) a oublié de substituer au nom du serveur de test celui utilisé en production !\nOn peut s’en charger grâce à la commande Find/Replace d’un éditeur de texte, ou à un coup de ligne de commande.\ncat liste_urls.txt | sed -e 's/k04-siteplubioclimatique.form.apps.paris.mdp/regles-urbanisme.paris.fr/'\n\n\nCeci fait, il est possible de télécharger tous les fichiers avec une boucle en ligne de commande.\nwhile read url; do wget --content-disposition $url; done &lt; liste_urls.txt\n\n\n\nTraitement\nToutes les planches PDF sont bâties sur le même modèle, il est donc aisé d’automatiser la conversion en JPG et le rognage du cartouche.\nPhotoshop sait très bien le faire, GIMP également, mais avec un plugin. Le plus rapide serait d’utiliser ImageMagick en ligne de commande.\n# Pour les curieux, la commande pour convertir et recadrer\n# le fichier PDF qu'on a utilisé plus haut\nconvert -density 300 D_05.pdf D_05.jpg\nconvert D_05.jpg -crop 6492x4720+232+136 +repage crop/D_05.jpg\n\n\n\nGéoréférencement\nPour géoréférencer les images obtenues, il faudrait simplement créer les fichiers World correspondant à chaque planche.\nPour cela, on remarque que les planches sont espacées très régulièrement : en fait, chaque planche est décalée de 750m en latitude et de 1000m en longitude. Pour générer les fichiers World, on pourrait donc partir des coordonnées de D_05 et recalculer les termes de translation (paramètres E et F) des autres planches, en laissant le facteur d’échelle et les termes de rotation inchangés.\n\nFaisons le test sur un exemple :\n\nTélécharger le fichier E_05.jpg.\nCopier le fichier D_05.wld en un fichier E_05.wld\nOuvrir le fichier E_05.wld et ajouter 1000 au nombre de la 5e ligne\nAjouter la couche E_05.jpg dans QGIS : Couches &gt; Ajouter une couche Raster \n\nMiracle : la couche est parfaitement ajustée !",
    "crumbs": [
      "TD PLU Bioclimatique"
    ]
  },
  {
    "objectID": "chapters/plu-bioclimatique.html#les-emplacements-réservés",
    "href": "chapters/plu-bioclimatique.html#les-emplacements-réservés",
    "title": "TD PLU Bioclimatique",
    "section": "Les emplacements réservés",
    "text": "Les emplacements réservés\nLe règlement du PLU liste dans son annexe V “les emplacements réservés en vue de la réalisation de certains types de logements” : logements locatifs sociaux et logements en BRS.\nCette liste est donnée sous la forme d’un tableau avec des adresses qui s’étend sur 33 pages d’un fichier PDF. Notre objectif va être de construire le semis de points des emplacements réservés à charger sous QGIS. Pour cela, il faut extraire les pages intéressantes, récupérer les données textuelles, nettoyer le fichier, géocoder les adresses, charger la couche et vérifier que tout va bien.\n\nUne page\nComme dans la partie précédente, on va se faire la main sur une seule page d’adresses, avant de voir comment généraliser. On restera dans le 8e arrondissement.\n\nExtraction\n\nSur le site Règles d’urbanisme de Paris, dans l’onglet Documentations, télécharger le volume 1 du Tome 2 du règlement.\nExtraire la page 51 du PDF.\n\nPour extraire la page, on peut utiliser par exemple Adobe Pro, PDF Sam Basic, ou bien QPDF si on préfère la ligne de commande.\nqpdf --empty --pages REG2A1.pdf 51 -- p51.pdf\n\nLa page extraite est téléchargeable ici si besoin.\n\n\nConversion\nEn examinant la page, on s’aperçoit que le texte a été transformé en image lors de la création du PDF : on ne peut directement copier/coller, il faut au préalable une étape de reconnaissance optique de caractères (OCR en anglais) pour récupérer le texte.\n\nPlusieurs options s’offrent à nous :\n\nSi on dispose d’Acrobat Pro (version payante du célèbre lecteur de PDF), on peut utiliser la fonction Scan et OCR.\nSi on aime les GAFAM, on peut recourir à un LLM généraliste comme ChatGPT, Gemini, DeepSeek ou Le Chat.\n\n\n\nOn peut aussi faire appel à des services plus spécialisés, peu chers et remarquablement efficaces, comme ExtractTable.com, créé par une jeune entreprise indienne. C’est celle que nous allons retenir. Pour les besoins du cours vous pouvez utiliser la clé API ci-dessous.\n\nAPI_KEY = H1qZ3YHuNPJR6ueRTpcYEyphdrTilu8wZR3bxPAK\n\nLe fichier Excel qui en résulte est téléchargeable ici si besoin.\n\n\nNettoyage\nAvant le géocodage, un prétraitement des données est nécessaire.\n\nIl faut ajouter une colonne CP et une colonne VILLE.\nLa colonne Adresse contient parfois deux adresses, on va les séparer à la main, en dupliquant la ligne concernée et ne conservant qu’une adresse dans chacune des deux lignes obtenues.\n\n\nLe fichier nettoyé est téléchargeable ici en Excel et là en CSV si besoin.\n\n\nGéocodage\nPour géocoder le fichier, rendez-vous sur le Géocodeur de la Base Nationale Adresse.\n\nLe fichier géocodé est téléchargeable ici en CSV si besoin.\n\n\nChargement\nLe fichier CSV géocodé s’ouvre directement avec QGIS.\n\nCouche &gt; Ajouter une couche de texte délimité\n\n\n\n\nVérifications\nIl est bon de vérifier les imprécisions éventuelles dans le géocodage. Ainsi, le géocodeur a traduit l’adresse 1-3 rue de Cerisoles par le 3 rue de Cerisoles. En conséquence, le point n’est pas correctement placé. Fort heureusement, le géocodeur fournit des indications sur le degré de confiance à accorder aux résultats via le champ result_score. On peut filtrer les enregistrements avec les scores les plus bas.\n\n\n\n\nPleins de pages\nEt si l’on devait traiter les 33 pages pour reconstituer l’ensemble du semis de points ? Quelques indications seulement sur ce que l’on pourrait faire :\n\nUtiliser l’API d’ExtractTable plutôt que l’interface graphique pour extraire en lot les données.\nFusionner les fichiers CSV obtenus.\nDédupliquer les lignes en détectant les doubles adresses avec une expression régulière.\n\nVoici la carte des emplacements réservés tels qu’ils étaient avant l’enquête publique, que j’avais constituée en 2023. Voici également la couche (au format GeoJSON) des données qu’elle représente.\nChargez cette couche dans QGIS. Identifiez-vous sur la feuille D5 des emplacements réservés qui ont disparu après l’enquête publique ?…\n\n\nSolution\n\nPar exemple le 30 bis rue Copernic, à l’ouest, sans doute parce qu’il y avait déjà un projet engagé…",
    "crumbs": [
      "TD PLU Bioclimatique"
    ]
  },
  {
    "objectID": "chapters/plu-bioclimatique.html#références",
    "href": "chapters/plu-bioclimatique.html#références",
    "title": "TD PLU Bioclimatique",
    "section": "Références",
    "text": "Références\n\nSource des données\nLes emplacements réservés pour logements sont désormais en open-data sur le site de la Ville de Paris ici.\n\n\nBibliographie\nÀ plusieurs reprises, nous avons eu recours à des programmes en ligne de commande pour automatiser des tâches.\nPour en savoir plus sur la ligne de commande et apprendre à maîtriser le côté obsur de l’informatique, je recommande le livre La ligne de commande par l’exemple, de Céline Chevalier, Sébastien Desreux, Vincent Fourmond (Paris, H&K, 2013). Un ouvrage accessible, pédagogique et drôle.",
    "crumbs": [
      "TD PLU Bioclimatique"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html",
    "href": "chapters/qgis-intro.html",
    "title": "Introduction à QGIS",
    "section": "",
    "text": "Dans ce chapitre, nous allons créer une première carte : un fond de plan cartographique centré sur la CA Paris Vallée de la Marne, sur lequel nous allons superposer des couches vectorielles de description administrative du territoire.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#installer-qgis",
    "href": "chapters/qgis-intro.html#installer-qgis",
    "title": "Introduction à QGIS",
    "section": "Installer QGIS",
    "text": "Installer QGIS\nQGIS est un logiciel SIG compatible avec Linux, Unix, Mac OS X, Windows et Android. La dernière version (3.44.3) disponible sur le site officiel.\nPour utiliser l’installateur officiel, il faut disposer des droits administrateurs sur l’ordinateur cible. Si on ne les a pas, on peut télécharger une version portable que l’on placera dans son répertoire utilisateur ou sur une clé USB. Une version portable de QGIS est disponible sur le blog SIG & Territoires.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#mise-en-place",
    "href": "chapters/qgis-intro.html#mise-en-place",
    "title": "Introduction à QGIS",
    "section": "Mise en place",
    "text": "Mise en place\nLancer QGIS, créer un nouveau projet.\n\nProjet → Nouveau\n\n\nFond de plan\nAjouter le fond de carte OpenStreetMap.\n\nCouche → Ajouter une couche → Ajouter une couche XYZ\nConnexions XYZ → OpenStreetMap\nAjouter\n\nDans le coin inférieur droit, remarquez qu’un SCR a été automatiquement défini : EPSG:3857. C’est celui de la première couche ajoutée.\nSi nous devions ajouter des couches exprimées dans un autre SCR, QGIS ferait la conversion de manière transparente, à condition qu’il puisse déterminer sans ambiguité le SCR de la couche fournie.\n\n\nSCR, Késako ?\n\nUn système de coordonnées de référence est le référentiel qui donne du sens aux valeurs numériques que prennent des coordonnées géographiques (latitude, longitude, altitude). On pourra se référer utilement à la documentation de QGIS.\n\n\nPour mieux voir les entités vectorielles que l’on ajoutera par la suite, on peut déjà rendre le fond de plan transparent et le passer en niveau de gris.\nAvec la couche sélectionnée :\n\nCouche → Propriétés de la couche\nTransparence → Opacité globale → 50%\nSymbologie → Rendu de couche → Niveaux de gris → [Par clarté]\n\n\n\n\nCouches vectorielles\nTélécharger la géodatabase préparée spécialement pour ce TP. Elle contient quelques données issues de la base AdminExpress de l’IGN.\n\n\nGéodatabase, ESRI Shapefile ?\n\nPlusieurs formats existent pour stocker de l’information géographique. QGIS travaille par défaut avec des géodatabases. Vous trouverez souvent des fichiers au format ESRI Shapefile. On retiendra qu’une géodatabase (extension gpkg) est capable de stocker plusieurs couches dans un même fichier, alors que le format ESRI Shapefile (extension principale shp) crée six différents fichiers pour stocker l’information d’une seule couche vectorielle. Pour les détails techniques, se référer à la documentation.\n\nAjouter la couche communes contenue dans la géodatabase.\n\nCouche → Ajouter une couche → Ajouter une couche vecteur\nSource → Jeux de données vectorielles\nAller chercher le ficher ade_simplifie.gpkg\nDans la fenêtre qui s’affiche, sélectionner la couche commune\n\n\nOn va modifier la symbologie de la couche pour ne conserver que les contours de chaque objet, sans ce vilain fond opaque, puis ajouter des étiquettes donnant le nom de la commune (on pourra personnaliser la police et le corps).\nAvec la couche sélectionnée :\n\nCouche → Propriétés de la couche\nSymbologie → Remplissage simple → Style de remplissage → Pas de remplissage\nÉtiquettes → Étiquettes simples → Valeur → nom_officiel",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#manipulations",
    "href": "chapters/qgis-intro.html#manipulations",
    "title": "Introduction à QGIS",
    "section": "Manipulations",
    "text": "Manipulations\n\nExplorer les données\nÀ chaque objet de la couche communes correspondent des données. On peut les consulter avec l’outil Identifier des données accessible par la barre d’outils. Pour les communes, un champ important est le code_insee. C’est lui qui identifie la commune de manière unique, on en aura besoin ultérieurement.\n\n\nDe l’importance des métadonnées\n\nMême si les intitulés des champs sont ici clairs, il est de bonne pratique de toujours consulter les métadonnées d’une source pour s’assurer d’avoir bien tout compris. Dans le cas présent, on ira voir sur le site de l’IGN, à la page ADMIN Express.\n\n\nUne autre manière d’explorer la couche est d’afficher sa table d’attributs.\n\nCouche → Ouvrir la table d’attributs ou F6.\n\n\n\nSélection manuelle\nOn peut sélectionner manuellement une ou plusieurs entités à l’aide de l’outil de la barre des tâches.\nOn notera :\n\ndans le menu déroulant, les modes de sélections sont possibles: rectangle de sélection, polygone, main levée, par rayon.\ndes raccourcis-claviers utiles : SHIFT pour ajouter des objets à la sélection courante, CTRL pour les retrancher.\n\nSélectionner les trois communes de Champs-sur-Marne, Noisiel et Émerainville.\n\n\n\nStatistiques descriptives\nOn peut calculer aisément certains agrégats (moyenne, médiane, etc.) sur les attributs des entités sélectionnés.\n\nVue → Résumé statistique\n\n\n\nQuelle est la population totale de ces trois communes ?\n\n50 124 habitants (au 1er janvier 2022).\n\n\n\nQuelle est la superficie cadastrale totale de ces trois communes ?\n\n1 710 hectares.\n\n\n\n\nCalculs géométriques\nUn SIG est capable de calculer la superficie de chaque polygone. On va vérifier que la superficie calculée est cohérente avec la superficie cadastrale renseignée dans la table attributaire.\nOuvrir la table d’attributs F6, puis la calculatrice de champs via le bouton en forme de boulier dans la barre d’outils, également CTRL+I.\nDans la fenêtre qui s’ouvre : * Indiquer le nom du champ à créer (on peut l’appeler superficie) * Sélectionner la case champ virtuel (ie. le champ ne sera pas persistent) * Indiquer le type du champ (entier) * Renseigner la formule pour calculer le champ : area(@geometry) * Valider\n\n\nQuelle sera l’unité du champ superficie ?\n\nIl dépend bien sûr de l’unité employée par le SCR de la carte. Pour le nôtre, c’est le mètre. Le champ superficie sera donc exprimé en mètres-carrés. On pourra diviser par 10000 pour le convertir en hectares.\n\n\nLe champ superficie figure bien désormais dans la table attributaire. On peut calculer la superficie des trois communes de la même manière qu’on a calculé celle de la population.\n\n\nQuelle est la superficie calculée totale de ces trois communes ?\n\n1 737,29 ha. L’écart est de 17,29 ha avec la superficie cadastrale, marge &lt;1%.\n\nOn peut également utiliser l’outil de mesure de longueur (CTRL+ALT+M) ou d’aires (CTRL+ALT+J) pour des calculs ponctuels sur la carte.\n\n\nAffichage par catégories\nOn va désormais colorer les communes différemment en fonction de l’EPCI auquel elles appartiennent.\n\nCouche → Propriétés de la couche → Symbologie → [catégorisé]\nValeur → [codes_siren_des_epci]\nSymboles → Remplissage simple → Style de remplissage → [continue]\nBouton Classer\nBouton Appliquer\n\nOn voit nettement se dessiner les 7 EPCI présents dans la base.\n\n\n\nMillefeuille administratif ?\n\nVous noterez dans la légende que le champ codes_siren_des_epci contient parfois deux numéros SIREN : certaines communes appartient bien à deux EPCI en même temps (Métropole du Grand Paris + EPT).\n\n\n\nSélection avancée\nOn va désormais sélectionner toutes les communes appartenant à la CA Paris Vallée de la Marne en testant deux méthodes.\n\nSélection par attributs\nOn peut sélectionner l’ensemble des entités de la couche des communes dont le champ code_siren_des_epci contient la valeur 200057958 grâce à la sélection par expression (CTRL+F3)\n\nÉditer → Sélection → Sélectionner des entités à l’aide d’une sélection\nExpression → [“codes_siren_des_epci” = ‘200057958’]\n\n\n\n\nSélection par géométrie\nOn peut aussi sélectionner l’ensemble des entités de la couche des communes qui sont situées à l’intérieur du polygone représentant la CA Paris Vallée de la Marne dans la couche des EPCI.\nPour cela, on va ajouter la couche vectorielle des EPCI qui figure dans la même géodatabase que la couche des communes et lui appliquer le style qui convient. Pour cela, se référer au début du TD.\nSélectionner ensuite le polygone représentant la CA Paris Vallée de la Marne.\n\nVecteur → Outils de recherche → Sélection par localisation\nSélectionner les entités depuis → ade_simplifiee - communes\nOù les entités → est à l'intérieur\nEn comparant les entité de → ade_simplifiee - epci\ncocher la case entités sélectionnées uniquement\n\n\n\n\n\nExport\nCréons maintenant un couche contenant uniquement les 12 communes de la CA Paris Vallée de la Marne. On sauvegardera cette couche dans notre géodatabase initiale.\n\nPanneau des couches →  clic-droit couche communes\nExporter → Sauvegarder les entités sélectionnées sous\n\n\n\n\nJointure attributaire\nReprésentons désormais les différences de population entre les communes.\nOn serait tenté de faire varier les couleurs des polygones du plus clair au plus foncé : les géomaticiens appellent ces cartes des cartes teintées, ou cartes choroplèthes. Mais pas de choroplèthes avec des données stock… on fera donc varier la taille de points représentant les communes.\nDans la géodatabase initiale, charger la couche chef_lieu_de_commune. Elle contient un semis de points, un pour chaque chef-lieu (c’est-à-dire la mairie).\nOuvrir la table attributaire : constater qu’il y a bien un champ code_insee_de_la_commune, mais pas (encore) de champ population… Qu’à cela ne tienne : on va l’ajouter, en joignant la table des chefs-lieux des communes à celle des communes.\nAvec la couche des chefs-lieux sélectionnés :\n\nCouche → Propriétés de la couche → Jointures\nCliquer le bouton +\nJoindre la couche → ade_simplifiee - communes, ade_simplifie\nChamp de jointure → code_insee\nChamp dans la couche cible → code_insee_de_la_commune\nChamps joints → population\n\n\n\n\nAffichage gradué\nOn peut désormais modifier la symbologie et faire varier la taille des points en fonction de la valeur du champ population.\n\nCouche → Propriétés de la couche → Symbologie\n\n\nSélectionner gradué\n\n\nValeur → xxx_population\nMéthode → Taille\nMode → intervalle égal\n\n\n\nDiscrétisation\n\nOn comprend bien que le choix des seuils, du nombre de catégories, etc. est stratégique, et qu’on peut faire dire à des mêmes données des choses très différentes selon les choix opérés…",
    "crumbs": [
      "Introduction à QGIS"
    ]
  },
  {
    "objectID": "chapters/qgis-intro.html#export-1",
    "href": "chapters/qgis-intro.html#export-1",
    "title": "Introduction à QGIS",
    "section": "Export",
    "text": "Export\nExportons notre carte en PDF. Il faut pour cela créer une mise en page.\n\nProjet → Nouvelle mise en page\n\nDans la fenêtre qui s’ouvre : - Insérer un bloc carte - Insérer un bloc de texte pour le titre - Insérer un bloc légende - Insérer une échelle graphique - Insérer une flèche indiquant le nord - …\nUne fois tous les paramètres ajustés, exporter la carte en PDF.",
    "crumbs": [
      "Introduction à QGIS"
    ]
  }
]